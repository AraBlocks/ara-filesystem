#!/usr/bin/env node

const debug = require('debug')('ara-filesystem')
const { info, warn, error, log } = require('ara-console')
const { basename, resolve } = require('path')
const { stat, access } = require('fs')
const cliWidth = require('cli-width')
const inquirer = require('inquirer')
const differ = require('ansi-diff-stream')
const pify = require('pify')
const program = require('yargs')
const afs = require('../')
const fs = require('fs')
const ProgressStream = require('progress-stream')
const ProgressBar = require('progress')
const bytes = require('pretty-bytes')
const table = require('table')
const prettyjson = require('prettyjson')
const rc = require('../rc')()

const isDirectory = require('is-directory')
const isFile = require('is-file')
const isSymlink = require('is-symlink')

const ignored = require('../lib/ignore')
const { kAidPrefix } = require('../constants')

const toLower = (x) => String(x).toLowerCase()
const $0 = basename(process.argv[1] || package.name)

process.on('unhandledRejection', onfatal)
process.on('uncaughtExeption', onfatal)

const { argv } = program
  .usage("usage: $0 [-hDV] [options] <command> [options]")
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output"
  })
  .option('help', {
    alias: 'h',
    describe: "Show this help message"
  })
  .option('version', {
    alias: 'V',
    describe: "Show program version"
  })
  .option('force', {
    alias: 'f',
    type: 'boolean',
    describe: 'Force operation',
  })
  .command('create <owner>', "Create AFS with given identity", (program) => {
    program
      .positional('owner', {
        type: 'string',
        describe: "This AFS owner's ARA decentralized identity (did) URI"
      })
      .option('secret', {
        alias: 's',
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('archiverNetwork', {
        type: 'string',
        required: true,
        default: rc.network.archiver,
        describe: 'Network name of the key for the DID archiver in the keyring',
      })
      .option('resolverNetwork', {
        type: 'string',
        default: rc.network.resolver,
        required: true,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        default: rc.network.identity.keyring ,
        describe: 'Path to the keyring',
      })
  }, oncreate)
  .command('add <did> <pathspec...>', "Add files or directories to an AFS", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .positional('pathspec', {
        type: 'string',
        describe: "The file(s) you wish to add to AFS"
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, onadd)
  .command('remove <did> <pathspec...>', "Remove files or directories from an AFS", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .positional('pathspec', {
        type: 'string',
        describe: "The file(s) you wish to remove from AFS"
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, onremove)
  .command('history <did>', "Retrieve the revision history of this AFS", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, onhistory)
  .command('commit <did>', "Push local staged AFS changes to the Ethereum blockchain and DCDN", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .option('price', {
        alias: 'P',
        type: 'number',
        describe: "Price (in ARA) to set the cost of the AFS"
      })
      .option('force', {
        alias: 'f',
        type: 'boolean',
        describe: 'Force commit operation',
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, oncommit)
  .command('set-price <did> [price]', "Publish price for the given AFS", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .positional('price', {
        type: 'number',
        describe: "Cost associated with an AFS (in ARA)"
      })
      .option('force', {
        alias: 'f',
        type: 'boolean',
        describe: 'Force set price operation',
      })
  }, onsetprice)
  .command('get-price <did>', "Return the price for a given AFS", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
  }, ongetprice)
  .command('destroy <did>', "Destroy AFS locally and remotely", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .option('force', {
        alias: 'f',
        type: 'boolean',
        describe: 'Force destroy operation',
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, ondestroy)
  .command('unarchive <did> [pathspec]', "Unarchive an AFS to a directory", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An AFS ARA decentralized identity (did) URI"
      })
      .positional('pathspec', {
        type: 'string',
        describe: "The path where the AFS should be extracted."
      })
      .option('secret', {
        alias: 's',
        required: true,
        type: 'string',
        describe: 'Shared secret for the keyring',
      })
      .option('network', {
        alias: 'n',
        type: 'string',
        required: true,
        default: rc.network.resolver,
        describe: 'Network name of the key for the DID resolver in the keyring',
      })
      .option('keyring', {
        alias: 'k',
        type: 'string',
        required: true,
        default: rc.network.identity.keyring + ".pub",
        describe: 'Path to the keyring',
      })
  }, onunarchive)
  // metadata commands
  .command('metadata', "CRUD operation interface for an AFS' metadata", (program) => {
    program
      .command('write-key <did> <key> <value>', "Write a key-value pair to the AFS' metadata file", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
          .positional('key', {
            type: 'string',
            describe: "The key to write"
          })
          .positional('value', {
            type: 'string',
            describe: "The value to write"
          })
          .option('print', {
            alias: 'p',
            type: 'boolean',
            describe: 'Print full metadata after write'
          })
        }, onmetadatawritekey)
      .command('read-key <did> <key>', "Read a key's value from AFS metadata", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
          .positional('key', {
            type: 'string',
            describe: "The key to write"
          })
        }, onmetadatareadkey)
      .command('delete-key <did> <key>', "Delete a key-value pair from the AFS' metadata file", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
          .positional('key', {
            type: 'string',
            describe: "The key to write"
          })
        }, onmetadatadeletekey)
      .command('clear <did>', "Clears all metadata from an AFS", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
        }, onmetadataclear)
      .command('print <did>', "Prints current metadata for an AFS", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
        }, onmetadataprint)
      .command('write-file <did> <filepath>', "Writes contents of entire file to metadata", (program) => {
        program
          .positional('did', {
            type: 'string',
            describe: "An AFS ARA decentralized identity (did) URI"
          })
          .option('print', {
            alias: 'p',
            type: 'boolean',
            describe: 'Print full metadata after write'
          })
        }, onmetadatawritefile)
  })

void async function main() {
  if (argv.debug) {
    require('debug').enable('ara-filesystem*')
  }
}()

async function oncreate(argv) {
  let owner = argv.owner

  if (null == owner) {
    onfatal(new Error("Missing AFS owner DID. See 'afs create --help'."))
  }

  if (0 == owner.indexOf('did:') && 0 != owner.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a DID URI with an 'ara' method."))
  }

  if (0 != owner.indexOf('did:ara:')) {
    owner = `${kAidPrefix}${owner}`
  }

  const { secret, resolverNetwork, archiverNetwork, keyring } = argv
  const keyringOpts = { secret, resolverNetwork, archiverNetwork, keyring }
  const { password } = await promptForPassword()

  let arafs
  try {
    arafs = await afs.create({ owner, password, keyringOpts })
  } catch (err) { onfatal(err) }

  info('New AFS created with DID: \n\n\t\t\t< %s >\n', arafs.afs.did)
  info('Please safely store the following 12 word mnemonic phrase for this AFS.' +
    ' This phrase will be required to restore and delete this AFS.'+
    ' It will never be shown again: \n\n\t\t\t< %s >\n', arafs.mnemonic)

  arafs.afs.close()
}

async function onhistory(argv) {
  let did = argv.did
  if (null == did) {
    onfatal(new Error("Missing AFS DID. See 'afs add --help'."))
  }

  if (0 == did.indexOf('did:') && 0 != did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a DID URI with an 'ara' method."))
  }

  if (0 != did.indexOf('did:ara:')) {
    did = 'did:ara:' + did
  }

  const { password } = await promptForPassword()

  const tableOpts = {
    columnCount: 3,
    border: table.getBorderCharacters('ramac'),
    columnDefault: {
      paddingLeft: 1,
      paddingRight: 1,
      width: parseInt(((cliWidth() || 30) - 10)/3),
    },
    columns: [
      { width: 4 },
      { width: 4 },
      { width: 30 },
    ]
  }

  const { secret, network, keyring } = argv
  const keyringOpts = { secret, network, keyring }

  try {
    const arafs = await afs.create({
      did,
      password,
      keyringOpts
    })
    const stream = table.createStream(tableOpts)

    arafs.afs.history(argv.partition || arafs.afs.HOME)
      .on('error', onfatal)
      .on('end', () => process.exit(0))
      .on('data', (log) => {
        if (true != argv['border']) {
          console.log('%s\t%s\t%s',
            log.version,
            log.type.toUpperCase(),
            log.name
          )
        } else {
          stream.write([
            log.version,
            log.type.toUpperCase(),
            log.name,
          ])
        }
      })
  } catch (err) {
    onfatal(err)
  }
}

async function onadd(argv) {
  let [ ...paths ] = argv.pathspec
  let did = argv.did

  if (!did) { onfatal(new Error("Missing AFS DID. See 'afs add --help'.")) }
  if (!paths || !paths.length) {
    onfatal(new Error("Missing local file paths. See 'afs add --help'."))
  }

  info("id: %s", did)
  info("paths: ", paths)

  const { secret, network, keyring } = argv
  const keyringOpts = { secret, network, keyring }

  const { password } = await promptForPassword()

  let instance
  try {
    instance = await afs.add({
      did,
      paths,
      password,
      keyringOpts
    })
    info("file(s) successfully added")
  } catch (err) {
    onfatal(err)
  }
  instance.close()
}

async function onremove(argv) {
  let [ ...paths ] = argv.pathspec
  let did = argv.did

  if (!did) { onfatal(new Error("Missing AFS DID. See 'afs remove --help'.")) }
  if (!paths || !paths.length) {
    onfatal(new Error("Missing local file paths. See 'afs remove --help'."))
  }

  info("id: %s", did)
  info("paths: ", paths)

  const { secret, network, keyring } = argv
  const keyringOpts = { secret, network, keyring }

  const { password } = await promptForPassword()
  let instance
  try {
    instance = await afs.remove({
      did,
      paths,
      password,
      keyringOpts
    })
    info("file(s) successfully removed")
  } catch (err) {
    onfatal(err)
  }
  instance.close()
}

async function oncommit({ did, price, secret, network, keyring }) {
  if (!did) { onfatal(new Error("Missing AFS DID. See 'afs remove --help'.")) }

  const { password } = await promptForPassword()

  const keyringOpts = { secret, network, keyring }

  let result = argv.force
  if (!result) {
    try {
      const cost = await afs.estimateCommitGasCost({ did, password, price, keyringOpts })
      const { answer } = await promptCostConfirmation(cost)
      result = answer
    } catch (err) {
      onfatal(err)
    }
  }

  if (result) {
    info("committing with identity: %s", did)
    const result = await afs.commit({ did, password, price, keyringOpts })
    if (result instanceof Error) {
      onfatal(result)
    } else {
      info(`file(s) successfully committed using ${result.gasUsed} gas`)
    }
  } else {
    onfatal() // exit
  }
}

async function onsetprice({ did, price }) {
  price = price || 0
  info("setting price of AFS identity %s to %d", did, price)
  const { password } = await promptForPassword()

  let result = argv.force
  if (!result) {
    try {
      const cost = await afs.estimateSetPriceGasCost({ did, password, price })
      const { answer } = await promptCostConfirmation(cost)
      result = answer
    } catch (err) {
      onfatal(err)
    }
  }

  if (result) {
    await afs.setPrice({ did, password, price })
    info("price has been set to", price)
  } else {
    onfatal() // exit
  }
}

async function ongetprice({did}) {
  info("getting price of AFS identity %s", did)

  let price
  try {
    price = await afs.getPrice({ did })
  } catch (err) {
    onfatal(err)
  }

  info("price of", did, "is", price)
}

async function promptCostConfirmation(cost) {
  return await inquirer.prompt({
    type: 'confirm',
    name: 'answer',
    message: 
    `This operation will cost ${cost} ETH. Are you sure you
    want to proceed?`
  })
}

async function ondestroy({ did, force }) {

  info("attempting destroying AFS %s", did)

  const { password } = await promptForPassword()
  const { mnemonic } = await promptForMnemonic()

  let result = force
  if (!result) {
    const { answer } = await displayConfirmationPrompt({
      message: `Destroy will remove this AFS from the entire ARA network. Continue?`
    })
    result = answer
  }

  const keyringOpts = { secret, network, keyring }
  if (result) {
    try {
      await afs.destroy({ did, mnemonic, password, keyringOpts  })
    } catch (err) {
      onfatal(err)
    }
    info("destroyed AFS %s", did)
  }

  process.exit(1)
}

async function onunarchive({ did, pathspec: path, secret, network, keyring }) {

  info("unarchiving AFS with DID %s", did)

  const keyringOpts = { secret, network, keyring }

  try {
    await afs.unarchive({
      did,
      path,
      keyringOpts
    })
  } catch (err) {
    onfatal(err)
  }

  info("successfully unarchived AFS %s", did)
}


async function onmetadatawritekey({ did, key, value, print }) {
  info("writing key %s with value %s to AFS metadata", key, value)

  let result
  try {
    result = await afs.metadata.writeKey({
      did,
      key,
      value
    })
  } catch (err) {
    onfatal(err)
  }

  info("successfully wrote %s", key)
  if (print) {
    // info swallows prettyjson output
    console.log(prettyjson.render(result))
  }
}

async function onmetadatareadkey({ did, key }) {
  info("reading %s from AFS metadata", key)

  let result
  try {
    result = await afs.metadata.readKey({
      did,
      key
    })
  } catch (err) {
    onfatal(err)
  }

  console.log(prettyjson.render(result))
}

async function onmetadatadeletekey({ did, key }) {
  info("deleting %s from AFS metadata", key)

  try {
    await afs.metadata.delKey({
      did,
      key
    })
  } catch (err) {
    onfatal(err)
  }

  info("deleted %s from AFS metadata", key)
}

async function onmetadataclear({ did }) {
  info("clearing AFS metadata")

  try {
    await afs.metadata.clear({ did })
  } catch (err) {
    onfatal(err)
  }

  info("metadata cleared successfully!")
}

async function onmetadataprint({ did }) {
  const contents = await afs.metadata.readFile({ did })
  console.log(prettyjson.render(contents))
}

async function onmetadatawritefile({ did, filepath, print }) {
  info("writing contents of %s to AFS metadata", filepath)

  let result
  try {
    result = await afs.metadata.writeFile({
      did,
      filepath
    })
  } catch (err) {
    onfatal(err)
  }

  if (result) {
    console.log(prettyjson.render(result))
  }
}

async function promptForPassword() {
  return await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Please provide the passphrase for your identity. This is needed to " +
    "complete this action.\n" +
    "Passphrase:"
  }])
}

async function promptForMnemonic() {
  return await inquirer.prompt([{
    name: 'mnemonic',
    message: "Please provide the mnemonic associated with your AFS identity."
  }])
}

async function displayConfirmationPrompt({
  name = 'answer',
  message = 'Are you sure you want to continue?'
} = {}) {
  return await inquirer.prompt([{
    name,
    type: 'confirm',
    message
  }])
}

function onfatal(err) {
  if (err) {
    debug(err)
    error("fatal:", err.message)
  }
  process.exit(1)
}
